(function(){"use strict";function g(h,n,s,e,t,o,i){const c=t*o,a=n[3],m=n[4],k=new Uint32Array(h.buffer,0),[X,A,z,Y,v]=s;for(;;){const l=Atomics.add(n,0,1);if(l>=c)return;const M=l*i/4,C=M+i/4,F=l%t,x=Math.trunc(l/t);for(let w=M,p=0;w<C;w++,p++){const U=p%a+F*a,E=Math.trunc(p/a)+x*m,I=Math.fround((U+.5)/(A/2)-1),N=Math.fround(1-(E+.5)/(z/2));k[w]=e(I,N,X,A,z,Y,v)}}}let d=null,S=null,r=null,b=null,f=0,u=0,y=0;onmessage=async h=>{const[n,...s]=h.data;switch(n){case"init":{const[e,t,o,i,c,a,m]=s;S=new Uint8ClampedArray(e,0,t),r=new Int32Array(e,t+c,o/4),b=new Float32Array(e,t+o+c*2,i/4),f=a,u=m,y=t/(f*u);break}case"loadShader":{const[e]=s;d=(await import(e)).fragment,self.postMessage("loaded");break}case"runShader":{if(!d)throw new Error("No shader provided");g(S,r,b,d,f,u,y),Atomics.add(r,1,1)===r[2]-1&&Atomics.notify(r,1);break}default:console.warn(`Message "${n}" is not handled.`)}}})();
