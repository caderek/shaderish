(function(){"use strict";function m(o,c,r,t,e,l,i){const n=new Float32Array(4),S=e*l;for(;;){const d=Atomics.add(c,0,1);if(d>=S)return;const y=d*i,A=y+i,M=d%e,T=Math.trunc(d/e);for(let a=y,w=0;a<A;a+=4,w++){const b=w%8+M*8,k=Math.trunc(w/8)+T*8,L=Math.fround((b+.5)/(r[1]/2)-1),Z=Math.fround(1-(k+.5)/(r[2]/2));t(n,L,Z,r),o[a]=n[0]*255,o[a+1]=n[1]*255,o[a+2]=n[2]*255,o[a+3]=n[3]*255}}}let u=null,p=null,s=null,E=null,h=0,f=0,I=0;onmessage=async o=>{const[c,...r]=o.data;switch(c){case"init":{const[t,e,l,i,n,S]=r;p=new Uint8ClampedArray(t,0,e),s=new Int32Array(t,e,l/4),E=new Float32Array(t,e+l,i/4),h=n,f=S,I=e/(h*f);break}case"loadShader":{const[t]=r;u=(await import(t)).fragment,self.postMessage("loaded");break}case"runShader":{if(!u)throw new Error("No shader provided");m(p,s,E,u,h,f,I),Atomics.add(s,1,1)===s[2]-1&&Atomics.notify(s,1);break}default:console.warn(`Message "${c}" is not handled.`)}}})();
