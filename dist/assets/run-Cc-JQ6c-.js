(function(){"use strict";function k(o,a,s,t,e,l,c){const n=new Float32Array(4),f=e*l,p=a[3],z=a[4];for(;;){const d=Atomics.add(a,0,1);if(d>=f)return;const M=d*c,g=M+c,F=d%e,b=Math.trunc(d/e);for(let r=M,S=0;r<g;r+=4,S++){const C=S%p+F*p,X=Math.trunc(S/p)+b*z,Y=Math.fround((C+.5)/(s[1]/2)-1),x=Math.fround(1-(X+.5)/(s[2]/2));t(n,Y,x,s),o[r]=n[0]*255,o[r+1]=n[1]*255,o[r+2]=n[2]*255,o[r+3]=n[3]*255}}}let h=null,y=null,i=null,m=null,u=0,w=0,A=0;onmessage=async o=>{const[a,...s]=o.data;switch(a){case"init":{const[t,e,l,c,n,f]=s;y=new Uint8ClampedArray(t,0,e),i=new Int32Array(t,e,l/4),m=new Float32Array(t,e+l,c/4),u=n,w=f,A=e/(u*w);break}case"loadShader":{const[t]=s;h=(await import(t)).fragment,self.postMessage("loaded");break}case"runShader":{if(!h)throw new Error("No shader provided");k(y,i,m,h,u,w,A),Atomics.add(i,1,1)===i[2]-1&&Atomics.notify(i,1);break}default:console.warn(`Message "${a}" is not handled.`)}}})();
