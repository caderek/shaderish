(function(){"use strict";function I(o,s,r,e,t,h,c){const n=new Float32Array(4),M=t*h;for(;;){const l=Atomics.add(s,0,1);if(l>=M)return;const w=l*c,g=w+c,{w:y,h:T}=e,b=l%t,m=Math.trunc(l/t);for(let a=w,f=0;a<g;a+=4,f++){const L=f%8+b*8,Z=Math.trunc(f/8)+m*8,_=Math.fround((L+.5)/(y/2)-1),A=Math.fround(1-(Z+.5)/(T/2));r(n,_,A,e),o[a]=n[0]*255,o[a+1]=n[1]*255,o[a+2]=n[2]*255,o[a+3]=n[3]*255}}}let i=null,p=null,S=null,d=0,u=0,E=0;onmessage=async o=>{const[s,...r]=o.data;switch(s){case"init":{const[e,t,h,c,n]=r;p=new Uint8ClampedArray(e,0,t),S=new Uint32Array(e,t,h/4),d=c,u=n,E=t/(d*u);break}case"loadShader":{const[e]=r;i=(await import(e)).fragment,self.postMessage("loaded");break}case"runShader":{if(!i)throw new Error("No shader provided");const[e,t]=r;I(p,S,i,e,d,u,E),self.postMessage("rendered");break}default:console.warn(`Message "${s}" is not handled.`)}}})();
